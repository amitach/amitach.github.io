<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Understanding Ruby Self | Amit Acharya Technical Blog]]></title>
  <link href="http://amitach.github.io/blog/categories/understanding-ruby-self/atom.xml" rel="self"/>
  <link href="http://amitach.github.io/"/>
  <updated>2014-03-30T15:17:42+05:30</updated>
  <id>http://amitach.github.io/</id>
  <author>
    <name><![CDATA[Amit Acharya]]></name>
    <email><![CDATA[amitach@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Ruby: Understanding Ruby Self]]></title>
    <link href="http://amitach.github.io/blog/2014/03/30/metaprogramming-ruby-understanding-ruby-self/"/>
    <updated>2014-03-30T03:33:42+05:30</updated>
    <id>http://amitach.github.io/blog/2014/03/30/metaprogramming-ruby-understanding-ruby-self</id>
    <content type="html"><![CDATA[<h1>Self</h1>


<h4>With respect to an object</h4>




<p><p>
Every line of Ruby code is executed inside an object the so called current object. The current object is also known as self, because you can
access it with the self keyword.Only one object can take the role of self at a given time, but no object holds that role for a long time. In particular, when you call a method, the receiver becomes self. From that moment on, all instance variables are instance variables of self, and all methods called without an explicit receiver are called on self. As soon as your code explicitly calls a method on some other object, that other object becomes self.</p>

<p>``` ruby self in Ruby
class FooBaar</p>

<pre><code>def foo
    puts "#{self.inspect} 1"
    @a = "hello"
    bar() # Same as self.my_method()
    puts "#{self.inspect} 2"
    self
end

def bar
    puts "#{self.inspect} 3"
    @a = @a + " world"
    puts "#{self.inspect} 4"
end
</code></pre>

<p>end
 #Let&rsquo;s do the following things on irb and observe, the code above was pasted to irb
head :072 > self
 => main
head :073 > obj = FooBaar.new
 => #&lt;FooBaar:0x00000001b787d8>
head :074 > obj.foo</p>

<h1>&lt;FooBaar:0x00000001b787d8> 1</h1>

<h1>&lt;FooBaar:0x00000001b787d8 @a=&ldquo;hello&rdquo;> 3</h1>

<h1>&lt;FooBaar:0x00000001b787d8 @a=&ldquo;hello world&rdquo;> 4</h1>

<h1>&lt;FooBaar:0x00000001b787d8 @a=&ldquo;hello world&rdquo;> 2</h1>

<p> => #&lt;FooBaar:0x00000001b787d8 @a=&ldquo;hello world&rdquo;>
head :075 > self
 => main</p>

<p>```</p>

<p>Let&rsquo;s dissect it now. Following things have to be observed
<br/>
<br/>
<ul>
<blockquote></p>

<pre><code>Outside the context of any class/module etc. self always refers to an object called as &lt;strong&gt;main&lt;/strong&gt; created by Ruby for us
</code></pre>

<p></blockquote>
<blockquote></p>

<pre><code>As soon as you call method foo, the receiver obj becomes self &lt;p&gt;&lt;span class="quotes"&gt;(#FooBaar:0x00000001b787d8 1 )&lt;/span&gt;.
</code></pre>

<p></blockquote>
<blockquote>
  Because of that, the instance variable @a is an instance variable of obj, and the
method bar( ) is called on obj( ).
</blockquote>
 <blockquote>&ndash; As bar() is executed, obj is still self <span class="quotes">(#FooBaar:0x00000001b787d8 3 )</span> (observe the 3 got printed), so @a is still an instance variable of obj.</blockquote>
 <blockquote>
  Finally, foo( ) returns a reference to self<span class="quotes">(#FooBaar:0x00000001b787d8 @a=&ldquo;hello world&rdquo; )</span> and as expected the final value of the instance variable @a is &ldquo;hello world&rdquo;.
 </blockquote>
<blockquote>  At the end the self is <strong>main</strong> again outside the scope of obj </blockquote>
</ul>
</p></p>

<p><h1>Self</h1> <h4> With respect to classes and modules</h4>
<p>
Usually the role of self is taken by the last object who received a method
call. However, in a class or module definition (and outside of any method), the role of self is taken by the class or module</p>

<p>``` ruby self in classes/modules
result = class MyClass</p>

<pre><code>self
</code></pre>

<p>end
result # => MyClass</p>

<p>```</p>

<p>Let&rsquo;s look at one more example
``` ruby ruby classes are objects
class Foo</p>

<pre><code>@a = 1
def self.read
    @a
end
def write 
    @a = 2
end
def read
    @a
end
</code></pre>

<p>end</p>

<p>obj = Foo.new
obj.write
obj.read # => 2
Foo.read # => 1</p>

<p>```</p>

<p>As we can see the previous code defines two instance variables. Both @a but they are defined in different scopes and they belong to different objects
<br/><br/>
<ul>
<blockquote></p>

<pre><code>One @a is defined with obj as self, so it's an instance variable of obj object
</code></pre>

<p></blockquote>
<blockquote></p>

<pre><code>The other @a is defined with Foo as self, so it's an instance variable of the Foo Object (Remember classes are nothing but objects in Ruby) 
</code></pre>

<p></blockquote>
</ul></p>

<p>With the above concepts in mind we can build on and understand when exactly self is to be used and what does it refer to. There are many concepts which are built on the understanding of self like class_eval, class methods etc. We will look at them soon
</p></p>
]]></content>
  </entry>
  
</feed>
